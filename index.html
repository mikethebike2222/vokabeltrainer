<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Vokabeltrainer ‚Äì Mobile (Landscape + Gesten)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1b3d8f">
<link rel="manifest" href="manifest.webmanifest">
<link rel="apple-touch-icon" sizes="180x180" href="icon-192.png">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
<style>
  :root{
    --card-max-w: 94vw; --card-max-h: 62svh;
    --card-font: clamp(22px, 6vw, 36px);
    --tile-font: clamp(18px, 4.8vw, 30px);
    --radius: 16px;
  }
  @supports not (height: 1svh){ :root{ --card-max-h: 62vh; } }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{ margin:0; background:#f5f7fb; display:flex; flex-direction:column; align-items:center; padding:16px; -webkit-tap-highlight-color:transparent; }
  body.learn-mode{ font-family:Georgia, "Times New Roman", serif; background:#f7f4ee; }
  body.test-mode{ font-family:Arial, Helvetica, sans-serif; background:#f5f7fb; }

  header{ width:min(100%,1100px); display:grid; grid-template-columns:1fr auto auto; gap:8px; align-items:center; margin-bottom:8px; }
  h1{ margin:0; font-size:20px; }
  .badge{ padding:6px 10px; border-radius:999px; font-size:13px; }
  #modeIndicator{ background:#e7eefc; color:#1b3d8f; } body.learn-mode #modeIndicator{ background:#efe6d5; color:#6f4d1d; }
  #boxBadge{ background:#ffe9ee; color:#8f1b2b; }

  .progress{ width:min(100%,1100px); background:#eef2f7; border-radius:999px; height:10px; overflow:hidden; margin:6px 0 12px; }
  .progress>div{ height:100%; width:0%; background:linear-gradient(90deg,#61c454,#1aa34a); transition:width .25s; }
  .progress-label{ width:min(100%,1100px); display:flex; justify-content:space-between; font-size:12px; opacity:.8; }

  .stage{ width:min(100%,1100px); display:grid; grid-template-columns:1fr; gap:14px; }

  .card{
    width:min(var(--card-max-w),720px); height:var(--card-max-h);
    background:#fff; border-radius:var(--radius); box-shadow:0 8px 20px rgba(0,0,0,.08);
    display:flex; align-items:center; justify-content:center; text-align:center;
    font-size:var(--card-font); padding:22px; margin:10px auto; user-select:none; word-break:keep-all; overflow-wrap:anywhere;
  }
  .pair{ width:min(var(--card-max-w),720px); display:grid; grid-template-columns:1fr 1fr; gap:12px; margin:0 auto; }
  .tile{ border-radius:var(--radius); box-shadow:0 8px 20px rgba(0,0,0,.08); padding:18px; min-height:calc(var(--card-max-h)/2.4); display:flex; align-items:center; justify-content:center; text-align:center; font-size:var(--tile-font); word-break:keep-all; overflow-wrap:anywhere; }
  .tile.es{ background:#fff7e9; } .tile.de{ background:#eaf4ff; }

  .controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin:6px 0 8px; position:sticky; bottom:calc(10px + env(safe-area-inset-bottom,0px)); padding-bottom:calc(6px + env(safe-area-inset-bottom,0px)); }
  button{ padding:14px 18px; font-size:16px; border:0; border-radius:12px; cursor:pointer; min-height:44px; min-width:44px; background:#1b3d8f; color:#fff; }
  .secondary{ background:#6b7280; } .success{ background:#176427; } .danger{ background:#8f1b2b; } .ghost{ background:#e5e7eb; color:#111827; } .pill{ border-radius:999px; }

  #testActions{ display:none; gap:10px; justify-content:center; }
  #testActions button{ min-width:120px; }

  .drawer-toggle{ position:fixed; bottom:18px; right:18px; z-index:30; }
  .drawer{ position:fixed; top:0; right:-380px; width:360px; height:100vh; background:#fff; box-shadow:-16px 0 32px rgba(0,0,0,.08); z-index:25; transition:right .25s; padding:14px; overflow:auto; }
  .drawer.open{ right:0; }
  .panel{ background:#fff; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.08); padding:12px; margin-bottom:12px; }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  input[type="text"], select{ padding:11px 12px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; min-height:42px; }
  .table-wrap{ max-height:420px; overflow:auto; border:1px solid #e5e7eb; border-radius:10px; }
  table{ width:100%; border-collapse:collapse; font-size:14px; } th,td{ border-bottom:1px solid #eef2f7; padding:8px; text-align:left; }
  thead th{ position:sticky; top:0; background:#f9fbff; z-index:1; }

  /* Querformat: fast Fullscreen mit kleinem Rand + Safe-Area */
  @media (orientation:landscape){
    header, .progress, .progress-label, .drawer-toggle, .controls.global, .drawer{ display:none !important; }
    body { padding: 0; }
    .card, .pair{
      width: calc(100vw - 4vw - env(safe-area-inset-left) - env(safe-area-inset-right));
      height: calc(100vh - 4vw - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      max-width:none; max-height:none; margin: 2vw;
    }
    .card{ font-size: clamp(28px, 7vw, 50px); }
    .tile{ font-size: clamp(24px, 5.5vw, 44px); }
    #landscapeBadge{ 
      display:flex; position:fixed; 
      left: calc(12px + env(safe-area-inset-left)); 
      bottom: calc(12px + env(safe-area-inset-bottom));
    }
  }
  @media (max-width:520px){
    header{ grid-template-columns:1fr auto; gap:6px; }
    .progress-label{ display:none; }
    .drawer{ width:92vw; right:-92vw; }
    .drawer.open{ right:0; }
  }

  #landscapeBadge{
    display:none; width:42px; height:42px; border-radius:50%; background:#111827; color:#fff;
    align-items:center; justify-content:center; font-size:13px; opacity:.85; z-index:40;
  }

  #editPanel{ display:none; padding:10px; gap:8px; justify-content:center; }
  #editPanel input{ min-width:140px; }
</style>
</head>
<body class="learn-mode">

<header>
  <h1>Vokabeltrainer</h1>
  <div id="modeIndicator" class="badge">Lernen</div>
  <div id="boxBadge" class="badge">Box: ‚Äì</div>
</header>

<div class="progress"><div id="progressBar"></div></div>
<div class="progress-label">
  <div id="progressText">Fortschritt: 0 / 0 (0%)</div>
  <div id="completionText"></div>
</div>

<!-- Globale Controls (nur Portrait) -->
<div class="controls global">
  <button id="toggleModeBtn" class="secondary pill">Lernen</button>
  <button id="editBtn" class="pill">‚úèÔ∏è Bearbeiten</button>
  <button id="drawerToggle" class="ghost pill">‚ò∞ Werkzeug</button>
</div>

<div class="stage">
  <main>
    <!-- LERNMODUS -->
    <div id="learnPair" class="pair">
      <div id="tileEs" class="tile es">‚Äî</div>
      <div id="tileDe" class="tile de">‚Äî</div>
    </div>

    <!-- PR√úFMODUS -->
    <div id="testPair" class="pair" style="display:none;">
      <div id="testLeft" class="tile es">‚Äî</div>
      <div id="testRight" class="tile de">‚Äî</div>
    </div>
    <div id="testActions" class="controls">
      <button id="btnWrong" class="danger">‚ùå Falsch</button>
      <button id="btnRight" class="success">‚úÖ Richtig</button>
    </div>

    <!-- Inline-Edit (Portrait) -->
    <div id="editPanel" class="controls">
      <input id="editEs" type="text" placeholder="Spanisch">
      <input id="editDe" type="text" placeholder="Deutsch">
      <button id="saveEditBtn" class="success">Speichern</button>
      <button id="cancelEditBtn" class="secondary">Abbrechen</button>
    </div>

    <div id="metaInfo" style="text-align:center; opacity:.75; font-size:13px;">
      Box: <span id="metaBox">‚Äì</span> ‚Ä¢ Falsch gez√§hlt: <span id="metaWrong">0</span>
    </div>
  </main>
</div>

<!-- Querformat-Badge -->
<div id="landscapeBadge">B1</div>

<!-- Schublade / Werkzeug -->
<aside class="drawer" id="drawer">
  <div class="row" style="justify-content:space-between;">
    <h3>Werkzeuge</h3>
    <button id="drawerClose" class="ghost pill">Schlie√üen</button>
  </div>

  <div class="panel">
    <h3>Decks</h3>
    <div class="row">
      <select id="deckSelect"></select>
      <button id="deckAddBtn" class="pill">‚ûï</button>
      <button id="deckRenameBtn" class="pill secondary">‚úèÔ∏è</button>
      <button id="deckDeleteBtn" class="pill danger">üóëÔ∏è</button>
    </div>
  </div>

  <div class="panel">
    <h3>Richtung</h3>
    <div class="row">
      <button id="toggleDirectionBtn" class="pill">ES ‚Üí DE</button>
    </div>
  </div>

  <div class="panel">
    <h3>CSV Import (ES,DE)</h3>
    <input type="file" id="csvFile" accept=".csv">
    <div style="font-size:12px;opacity:.7">UTF-8 / Win-1252 / ISO-8859-1; Komma/Semikolon</div>
  </div>

  <div class="panel">
    <h3>Neue Karte</h3>
    <div class="row">
      <input type="text" id="spanish" placeholder="Spanisch">
      <input type="text" id="german" placeholder="Deutsch">
      <button id="addCardBtn">Hinzuf√ºgen</button>
    </div>
  </div>

  <div class="panel">
    <h3>Statistik</h3>
    <table id="statsTable">
      <tr><th>Box</th><th>Karten</th><th>F√§llig</th><th>N√§chstes</th></tr>
    </table>
  </div>

  <div class="panel">
    <h3>Alle Karten</h3>
    <div class="row" style="margin-bottom:8px;">
      <input type="text" id="searchInput" placeholder="Suchen ‚Ä¶ (ES/DE)">
      <select id="listSortSelect">
        <option value="boxdesc">Box ‚Üì</option>
        <option value="wrongdesc">Schwierigkeit ‚Üì</option>
        <option value="alphaes">Spanisch A‚ÄìZ</option>
        <option value="alphade">Deutsch A‚ÄìZ</option>
      </select>
      <label style="font-size:12px;"><input type="checkbox" id="showReserveChk"> Reserve</label>
    </div>
    <div class="table-wrap">
      <table>
        <thead><tr><th>Spanisch</th><th>Deutsch</th><th>Box</th><th>Falsch</th><th>Zuletzt</th><th>Aktion</th></tr></thead>
        <tbody id="cardsTable"></tbody>
      </table>
    </div>
  </div>

  <div class="panel">
    <h3>Verwalten</h3>
    <div class="row">
      <button id="deleteBtn" class="danger">Aktive Karte l√∂schen</button>
      <button id="resetProgressBtn" class="secondary">Nur Fortschritt</button>
      <button id="resetAllBtn" class="danger">Alles l√∂schen</button>
    </div>
  </div>

  <div class="panel" style="font-size:12px; opacity:.8">
    <div>Hinweis: Lernmodus zeigt nur <b>Box 1</b>. Pr√ºfmodus nutzt <b>alle f√§lligen</b> Karten.</div>
  </div>
</aside>

<script>
/* === Setup === */
function setVH(){ const vh=window.innerHeight*0.01; document.documentElement.style.setProperty('--vh', vh+'px'); }
addEventListener('resize', setVH); setVH();

const LS_DECKS="leitnerDecks";
function uuid(){ return Math.random().toString(36).slice(2,10); }
let decks=JSON.parse(localStorage.getItem(LS_DECKS)||"[]");
if(decks.length===0){ const id=uuid(); decks=[{id,name:"Spanisch ES‚ÜíDE"}]; localStorage.setItem(LS_DECKS,JSON.stringify(decks)); }
let currentDeckId=localStorage.getItem("leitnerCurrentDeck")||decks[0].id;
function deckKey(k){ return `${k}_${currentDeckId}`; }

/* === Leitner-Config === */
const boxLimits=[20,20,20,20,20];
const boxIntervals=[1,2,4,9,14];
const minBox1Size=20;

/* === State === */
let activeCards=JSON.parse(localStorage.getItem(deckKey("leitnerActive")))||[];
let reserveCards=JSON.parse(localStorage.getItem(deckKey("leitnerReserve")))||[];
let learnedCards=JSON.parse(localStorage.getItem(deckKey("leitnerLearned")))||[];
let mode="lernen";                          // "lernen" | "pr√ºfen"
let direction=localStorage.getItem(deckKey("leitnerDirection"))||"es2de"; // es2de | de2es
let testOrder=localStorage.getItem(deckKey("leitnerTestOrder"))||"random";

/* Lernmodus-Navigation (Next/Prev) */
let learnOrder=[];       // Array mit Referenzen (IDs) oder Indizes
let learnIndex=0;        // Zeiger im Lernmodus

function ensureSeed(){
  if(activeCards.length===0&&reserveCards.length===0&&learnedCards.length===0){
    activeCards=[{es:"hola",de:"hallo",box:1,lastSeen:null,wrong:0},{es:"adi√≥s",de:"auf Wiedersehen",box:1,lastSeen:null,wrong:0},{es:"gracias",de:"danke",box:1,lastSeen:null,wrong:0},{es:"por favor",de:"bitte",box:1,lastSeen:null,wrong:0},{es:"s√≠",de:"ja",box:1,lastSeen:null,wrong:0},{es:"no",de:"nein",box:1,lastSeen:null,wrong:0}];
    saveData();
  }
}
[activeCards,reserveCards,learnedCards].forEach(a=>a.forEach(c=>{ if(typeof c.wrong!=="number") c.wrong=0; if(!c.id) c.id=cryptoRandom(); }));
ensureSeed();

/* === DOM === */
const body=document.body;
const modeIndicator=document.getElementById("modeIndicator");
const boxBadge=document.getElementById("boxBadge");
const progressBar=document.getElementById("progressBar"), progressText=document.getElementById("progressText"), completionText=document.getElementById("completionText");

const learnPair=document.getElementById("learnPair"), tileEs=document.getElementById("tileEs"), tileDe=document.getElementById("tileDe");
const testPair=document.getElementById("testPair"), testLeft=document.getElementById("testLeft"), testRight=document.getElementById("testRight");
const testActions=document.getElementById("testActions"), btnRight=document.getElementById("btnRight"), btnWrong=document.getElementById("btnWrong");

const toggleModeBtn=document.getElementById("toggleModeBtn");
const editBtn=document.getElementById("editBtn");
const editPanel=document.getElementById("editPanel"); const editEs=document.getElementById("editEs"); const editDe=document.getElementById("editDe");
const saveEditBtn=document.getElementById("saveEditBtn"), cancelEditBtn=document.getElementById("cancelEditBtn");

const drawer=document.getElementById("drawer"), drawerToggle=document.getElementById("drawerToggle"), drawerClose=document.getElementById("drawerClose");
const toggleDirectionBtn=document.getElementById("toggleDirectionBtn");
const deckSelect=document.getElementById("deckSelect"), deckAddBtn=document.getElementById("deckAddBtn"), deckRenameBtn=document.getElementById("deckRenameBtn"), deckDeleteBtn=document.getElementById("deckDeleteBtn");
const csvFileInput=document.getElementById("csvFile"), addCardBtn=document.getElementById("addCardBtn");
const statsTable=document.getElementById("statsTable");
const resetProgressBtn=document.getElementById("resetProgressBtn"), resetAllBtn=document.getElementById("resetAllBtn"), deleteBtn=document.getElementById("deleteBtn");

const cardsTable=document.getElementById("cardsTable"), searchInput=document.getElementById("searchInput"), listSortSelect=document.getElementById("listSortSelect"), showReserveChk=document.getElementById("showReserveChk");
const metaBox=document.getElementById("metaBox"), metaWrong=document.getElementById("metaWrong");
const landscapeBadge=document.getElementById("landscapeBadge");

/* === Utils === */
function cryptoRandom(){ return Math.random().toString(36).slice(2,10) + Math.random().toString(36).slice(2,10); }
function saveData(){
  localStorage.setItem(deckKey("leitnerActive"),JSON.stringify(activeCards));
  localStorage.setItem(deckKey("leitnerReserve"),JSON.stringify(reserveCards));
  localStorage.setItem(deckKey("leitnerLearned"),JSON.stringify(learnedCards));
  localStorage.setItem(deckKey("leitnerDirection"),direction);
  localStorage.setItem(deckKey("leitnerTestOrder"),testOrder);
}
function saveDecks(){ localStorage.setItem(LS_DECKS,JSON.stringify(decks)); localStorage.setItem("leitnerCurrentDeck",currentDeckId); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function daysBetween(a,b){ return Math.floor((a-b)/(1000*60*60*24)); }
function getDueCards(){
  const today=new Date();
  return activeCards.filter(card=>{
    if(card.lastSeen===null) return true;
    return daysBetween(today,new Date(card.lastSeen))>=boxIntervals[card.box-1];
  });
}
function autoFillBox1(){
  const b1=activeCards.filter(c=>c.box===1).length;
  if(b1<minBox1Size && reserveCards.length>0){
    const need=Math.max(0,minBox1Size-b1);
    const add=reserveCards.splice(0,need);
    add.forEach(c=>{ c.box=1; c.lastSeen=null; if(typeof c.wrong!=="number") c.wrong=0; if(!c.id) c.id=cryptoRandom(); });
    activeCards.push(...add); saveData();
  }
}
function totals(){ const total=activeCards.length+reserveCards.length+learnedCards.length; const learned=learnedCards.length; return {total, learned}; }
function updateProgress(){
  const {total,learned}=totals();
  const pct= total? Math.round((learned/total)*100):100;
  progressBar.style.width=pct+"%";
  progressText.textContent=`Fortschritt: ${learned} / ${total} (${pct}%)`;
  completionText.textContent=(activeCards.length===0&&reserveCards.length===0&&total>0)?"√úbung abgeschlossen üéâ":"";
}
function updateStats(){
  statsTable.innerHTML=`<tr><th>Box</th><th>Karten</th><th>F√§llig</th><th>N√§chstes</th></tr>`;
  const dueAll=getDueCards();
  for(let b=1;b<=5;b++){
    const inBox=activeCards.filter(c=>c.box===b);
    const due=dueAll.filter(c=>c.box===b).length;
    let next="-";
    if(inBox.length){
      const ds=inBox.map(c=>{ if(!c.lastSeen) return new Date(0); const d=new Date(c.lastSeen); d.setDate(d.getDate()+boxIntervals[b-1]); return d; });
      const soonest=new Date(Math.min(...ds.map(d=>d.getTime())));
      next=soonest.getTime()>0?soonest.toLocaleDateString():"heute";
    }
    statsTable.insertAdjacentHTML("beforeend",`<tr><td>${b}</td><td>${inBox.length}</td><td>${due}</td><td>${next}</td></tr>`);
  }
}
function esc(s){ return (s||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m])); }

/* === Lernmodus: Reihenfolge & Navigation === */
function rebuildLearnOrder(){
  const pool = activeCards.filter(c=>c.box===1);
  learnOrder = pool.map(c=>c.id);
  shuffle(learnOrder);
  learnIndex = 0;
}
function getLearnCard(){
  if(learnOrder.length===0) rebuildLearnOrder();
  const idsInBox1 = new Set(activeCards.filter(c=>c.box===1).map(c=>c.id));
  // Entferne IDs, die nicht mehr existieren / nicht mehr Box1 sind
  learnOrder = learnOrder.filter(id => idsInBox1.has(id));
  if(learnOrder.length===0){ autoFillBox1(); rebuildLearnOrder(); }
  if(learnOrder.length===0) return null;
  // clamp index
  if(learnIndex<0) learnIndex=0;
  if(learnIndex>=learnOrder.length) learnIndex=learnOrder.length-1;
  const id = learnOrder[learnIndex];
  return activeCards.find(c=>c.id===id) || null;
}
function nextLearn(){
  learnIndex++;
  if(learnIndex>=learnOrder.length){ // am Ende: neu auff√ºllen/neu mischen
    autoFillBox1();
    rebuildLearnOrder();
  }
  renderLearn();
}
function prevLearn(){
  learnIndex = Math.max(0, learnIndex-1);
  renderLearn();
}
function renderLearn(){
  const card = getLearnCard();
  currentCard = card;
  if(!card){
    tileEs.textContent="‚Äî"; tileDe.textContent="Keine Karte in Box 1.";
    updateMeta(); return;
  }
  tileEs.textContent=card.es; tileDe.textContent=card.de;
  updateMeta();
}

/* === Auswahl & Render === */
let currentCard=null;
let testPhase="prompt"; // "prompt" -> "answer"

function pickNextTestCard(){
  autoFillBox1();
  let pool = getDueCards();
  if(pool.length===0) return null;
  if(testOrder==="hardest"){ pool.sort((a,b)=>(b.wrong||0)-(a.wrong||0)); return pool[0]; }
  shuffle(pool); return pool[0];
}

function render(){
  updateProgress(); updateStats();

  body.classList.toggle("test-mode", mode==="pr√ºfen");
  body.classList.toggle("learn-mode", mode==="lernen");
  modeIndicator.textContent = mode==="pr√ºfen" ? "Pr√ºfen" : "Lernen";
  toggleModeBtn.textContent = mode==="pr√ºfen" ? "Pr√ºfen" : "Lernen";
  toggleDirectionBtn.textContent = direction==="es2de" ? "ES ‚Üí DE" : "DE ‚Üí ES";

  if(mode==="lernen"){
    learnPair.style.display="grid"; testPair.style.display="none"; testActions.style.display="none";
    renderLearn();
  }else{
    learnPair.style.display="none"; testPair.style.display="grid"; testPhase="prompt"; testActions.style.display="none";
    currentCard = pickNextTestCard();
    if(!currentCard){
      testLeft.textContent="‚Äî"; testRight.textContent="Nichts f√§llig.";
      updateMeta(); return;
    }
    const src = (direction==="es2de") ? currentCard.es : currentCard.de;
    testLeft.textContent = src;
    testRight.textContent = "‚Äî";
    updateMeta();
  }
}
function updateMeta(){
  const b = currentCard ? currentCard.box : "‚Äì";
  document.getElementById("metaBox").textContent = b;
  document.getElementById("metaWrong").textContent = currentCard ? (currentCard.wrong||0) : 0;
  document.getElementById("boxBadge").textContent = "Box: " + b;
  document.getElementById("landscapeBadge").textContent = "B" + b;
}

/* === Pr√ºf-Flow === */
function revealAnswer(){
  if(mode!=="pr√ºfen" || !currentCard || testPhase!=="prompt") return;
  const tgt = (direction==="es2de") ? currentCard.de : currentCard.es;
  testRight.textContent = tgt;
  testPhase = "answer";
  testActions.style.display = "flex";
}
testPair.addEventListener("click", revealAnswer);

function haptic(){ try{ navigator.vibrate && navigator.vibrate(15); }catch(e){} }
btnRight.addEventListener("click", ()=>{
  if(mode!=="pr√ºfen" || !currentCard) return;
  haptic();
  if(currentCard.box===5){
    const i=activeCards.indexOf(currentCard); if(i>=0) activeCards.splice(i,1);
    learnedCards.push({...currentCard, learnedAt:new Date().toISOString()});
  }else{
    const next=currentCard.box+1;
    const nextCount=activeCards.filter(c=>c.box===next).length;
    if(nextCount<boxLimits[next-1]) currentCard.box=next;
    currentCard.lastSeen=new Date().toISOString();
  }
  saveData(); render();
});
btnWrong.addEventListener("click", ()=>{
  if(mode!=="pr√ºfen" || !currentCard) return;
  haptic();
  currentCard.box = Math.max(1, currentCard.box - 1);
  currentCard.wrong = (currentCard.wrong||0) + 1;
  currentCard.lastSeen = new Date().toISOString();
  saveData(); render();
});

/* === Bearbeiten === */
editBtn.addEventListener("click", ()=>{
  if(!currentCard) return;
  editPanel.style.display = (editPanel.style.display==="none"||editPanel.style.display==="") ? "flex" : "none";
  editEs.value = currentCard.es; editDe.value = currentCard.de; editEs.focus();
});
cancelEditBtn.addEventListener("click", ()=>{ editPanel.style.display="none"; });
saveEditBtn.addEventListener("click", ()=>{
  if(!currentCard) return;
  const newEs=editEs.value.trim(), newDe=editDe.value.trim();
  if(!newEs || !newDe){ alert("Bitte beide Felder ausf√ºllen."); return; }
  const dup = activeCards.some(c=>c!==currentCard && c.es===newEs)
           || reserveCards.some(c=>c.es===newEs)
           || learnedCards.some(c=>c.es===newEs);
  if(dup){ alert("Es existiert bereits eine Karte mit derselben spanischen Seite."); return; }
  currentCard.es=newEs; currentCard.de=newDe;
  saveData(); editPanel.style.display="none"; render();
});

/* === Drawer === */
document.getElementById("drawerToggle").onclick=()=>{ drawer.classList.toggle("open"); };
drawerClose.onclick=()=>drawer.classList.remove("open");

/* === Richtung === */
toggleDirectionBtn.addEventListener("click", ()=>{
  direction = (direction==="es2de") ? "de2es" : "es2de";
  saveData(); render();
});

/* === CSV Import === */
csvFileInput.addEventListener("change",(ev)=>{
  const file=ev.target.files[0]; if(!file) return;
  const rdr=new FileReader();
  rdr.onload=e=>{
    const buf=e.target.result;
    const decs=[new TextDecoder("utf-8"), new TextDecoder("windows-1252"), new TextDecoder("iso-8859-1")];
    let text="", used="utf-8";
    for(const d of decs){ const t=d.decode(buf); const bad=(t.match(/\uFFFD/g)||[]).length; if(bad===0){ text=t; used=d.encoding||used; break; } if(!text) text=t; }
    const lines=text.split(/\r?\n/); let imported=0;
    for(const raw of lines){
      if(!raw.trim()) continue;
      const sep=(raw.includes(";")&&(!raw.includes(",")||raw.indexOf(";")<raw.indexOf(",")))?";":",";
      const parts=raw.split(sep); if(parts.length<2) continue;
      let es=parts[0]?.trim().replace(/^"(.*)"$/,'$1'); let de=parts[1]?.trim().replace(/^"(.*)"$/,'$1');
      if(!es||!de) continue;
      const exists=activeCards.some(c=>c.es===es)||reserveCards.some(c=>c.es===es)||learnedCards.some(c=>c.es===es);
      if(!exists){ reserveCards.push({id:cryptoRandom(), es,de,box:1,lastSeen:null,wrong:0}); imported++; }
    }
    saveData(); alert(`Import: ${imported} Eintr√§ge (Encoding: ${used})`); render();
  };
  rdr.readAsArrayBuffer(file);
});

/* === Add Card === */
addCardBtn.onclick=()=>{
  const es=document.getElementById("spanish").value.trim();
  const de=document.getElementById("german").value.trim();
  if(!es||!de) return;
  const exists=activeCards.some(c=>c.es===es)||reserveCards.some(c=>c.es===es)||learnedCards.some(c=>c.es===es);
  if(exists){ alert("Schon vorhanden."); return; }
  activeCards.push({id:cryptoRandom(), es,de,box:1,lastSeen:null,wrong:0});
  document.getElementById("spanish").value=""; document.getElementById("german").value="";
  saveData(); rebuildLearnOrder(); render();
};

/* === L√∂schen === */
deleteBtn.onclick=()=>{
  if(!currentCard) return;
  if(!confirm("M√∂chtest du die aktive Karte wirklich l√∂schen?")) return;
  const idx=activeCards.indexOf(currentCard);
  if(idx>=0) activeCards.splice(idx,1);
  saveData(); rebuildLearnOrder(); render();
};

/* === Reset === */
resetProgressBtn.onclick=()=>{ if(!confirm("Nur Lernfortschritt zur√ºcksetzen?")) return;
  activeCards=activeCards.map(c=>({...c, box:1, lastSeen:null}));
  saveData(); rebuildLearnOrder(); render(); alert("Fortschritt zur√ºckgesetzt.");
};
resetAllBtn.onclick=()=>{ if(!confirm("Alle Daten dieser √úbung l√∂schen?")) return;
  localStorage.removeItem(deckKey("leitnerActive"));
  localStorage.removeItem(deckKey("leitnerReserve"));
  localStorage.removeItem(deckKey("leitnerLearned"));
  localStorage.removeItem(deckKey("leitnerDirection"));
  localStorage.removeItem(deckKey("leitnerTestOrder"));
  activeCards=[]; reserveCards=[]; learnedCards=[]; direction="es2de"; testOrder="random"; ensureSeed(); saveData(); rebuildLearnOrder(); render(); alert("Neu initialisiert.");
};

/* === Decks === */
function rebuildDeckSelect(){
  deckSelect.innerHTML="";
  decks.forEach(d=>{ const o=document.createElement("option"); o.value=d.id; o.textContent=d.name+(d.id===currentDeckId?" (aktiv)":""); deckSelect.appendChild(o); });
  deckSelect.value=currentDeckId;
}
rebuildDeckSelect();

deckSelect.onchange=()=>{
  currentDeckId=deckSelect.value; saveDecks();
  activeCards=JSON.parse(localStorage.getItem(deckKey("leitnerActive")))||[];
  reserveCards=JSON.parse(localStorage.getItem(deckKey("leitnerReserve")))||[];
  learnedCards=JSON.parse(localStorage.getItem(deckKey("leitnerLearned")))||[];
  direction=localStorage.getItem(deckKey("leitnerDirection"))||"es2de";
  testOrder=localStorage.getItem(deckKey("leitnerTestOrder"))||"random";
  [activeCards,reserveCards,learnedCards].forEach(a=>a.forEach(c=>{ if(typeof c.wrong!=="number") c.wrong=0; if(!c.id) c.id=cryptoRandom(); }));
  ensureSeed(); rebuildLearnOrder(); render();
};
deckAddBtn.onclick=()=>{ const name=prompt("Name der neuen √úbung:"); if(!name) return;
  const id=uuid(); decks.push({id,name}); saveDecks();
  currentDeckId=id; rebuildDeckSelect();
  activeCards=[]; reserveCards=[]; learnedCards=[]; direction="es2de"; testOrder="random"; ensureSeed(); saveData(); rebuildLearnOrder(); render();
};
deckRenameBtn.onclick=()=>{ const deck=decks.find(d=>d.id===currentDeckId); if(!deck) return;
  const name=prompt("Neuer Name:", deck.name); if(!name) return;
  deck.name=name; saveDecks(); rebuildDeckSelect();
};
deckDeleteBtn.onclick=()=>{ if(decks.length<=1){ alert("Mindestens eine √úbung muss bleiben."); return; }
  const deck=decks.find(d=>d.id===currentDeckId);
  if(!deck || !confirm(`‚Äû${deck.name}‚Äú wirklich l√∂schen?`)) return;
  localStorage.removeItem(deckKey("leitnerActive"));
  localStorage.removeItem(deckKey("leitnerReserve"));
  localStorage.removeItem(deckKey("leitnerLearned"));
  localStorage.removeItem(deckKey("leitnerDirection"));
  localStorage.removeItem(deckKey("leitnerTestOrder"));
  decks=decks.filter(d=>d.id!==currentDeckId);
  currentDeckId=decks[0].id; saveDecks(); rebuildDeckSelect(); deckSelect.onchange();
};

/* === Liste === */
function buildTable(){
  const q=searchInput.value.trim().toLowerCase(); const incl=showReserveChk.checked;
  let rows=activeCards.map(c=>({...c,_w:"aktiv"})); if(incl) rows=rows.concat(reserveCards.map(c=>({...c,_w:"reserve"})));
  if(q) rows=rows.filter(r=>(r.es||"").toLowerCase().includes(q)||(r.de||"").toLowerCase().includes(q));
  const sort=listSortSelect.value;
  rows.sort((a,b)=>{
    if(sort==="wrongdesc") return (b.wrong||0)-(a.wrong||0);
    if(sort==="alphaes") return (a.es||"").localeCompare(b.es||"");
    if(sort==="alphade") return (a.de||"").localeCompare(b.de||"");
    if(b.box!==a.box) return (b.box||0)-(a.box||0);
    return (b.wrong||0)-(a.wrong||0);
  });
  const tb=cardsTable; tb.innerHTML="";
  for(const r of rows){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td>${esc(r.es)}</td><td>${esc(r.de)}</td><td>${r.box||"-"}${r._w==="reserve"?"*":""}</td><td>${r.wrong||0}</td><td>${r.lastSeen?new Date(r.lastSeen).toLocaleDateString():"-"}</td><td><button class="ghost" data-e>Edit</button><button class="danger" data-d>Del</button></td>`;
    tr.querySelector("[data-e]").onclick=()=>{ const es=prompt("Spanisch:",r.es); if(es===null)return; const de=prompt("Deutsch:",r.de); if(de===null)return; if(!es.trim()||!de.trim())return;
      const coll=(arr,es0,same)=>arr.some(c=>c!==same&&c.es===es0);
      if(coll(activeCards,es,r)||coll(reserveCards,es,r)||coll(learnedCards,es,r)){ alert("Karte mit dieser spanischen Seite existiert bereits."); return; }
      r.es=es.trim(); r.de=de.trim(); saveData(); rebuildLearnOrder(); render(); };
    tr.querySelector("[data-d]").onclick=()=>{ if(!confirm("Karte l√∂schen?"))return; let arr=(r._w==="reserve")?reserveCards:activeCards; const i=arr.indexOf(r); if(i>=0)arr.splice(i,1); saveData(); rebuildLearnOrder(); render(); };
    tb.appendChild(tr);
  }
}
searchInput.oninput=buildTable; listSortSelect.onchange=buildTable; showReserveChk.onchange=buildTable;

/* === Modus-Toggle === */
toggleModeBtn.onclick=()=>{ mode = (mode==="lernen") ? "pr√ºfen" : "lernen"; editPanel.style.display="none"; render(); };

/* === Gesten: Lernmodus (links=next, rechts=prev, tippen=next) === */
(function learnGestures(){
  const area = learnPair;
  let startX=0, startY=0, dx=0, dy=0, touching=false;
  const THRESH_X = 45, THRESH_Y = 60; // etwas gro√üz√ºgig gegen Scroll
  function onStart(e){ const t=e.touches?e.touches[0]:e; startX=t.clientX; startY=t.clientY; dx=dy=0; touching=true; }
  function onMove(e){ if(!touching) return; const t=e.touches?e.touches[0]:e; dx=t.clientX-startX; dy=t.clientY-startY; }
  function onEnd(){
    if(!touching) return; touching=false;
    if(Math.abs(dy) > THRESH_Y) return; // vertikale Geste ignorieren
    if(dx < -THRESH_X){ nextLearn(); return; }     // links wischen
    if(dx >  THRESH_X){ prevLearn(); return; }     // rechts wischen
    // Tap
    nextLearn();
  }
  ["touchstart","mousedown"].forEach(ev=> area.addEventListener(ev, onStart, {passive:true}));
  ["touchmove","mousemove"].forEach(ev=> area.addEventListener(ev, onMove, {passive:true}));
  ["touchend","mouseup","mouseleave"].forEach(ev=> area.addEventListener(ev, onEnd));
})();

/* === Pr√ºfmodus: Tippen zeigt Antwort (Buttons), Gesten optional wie gehabt === */
(function testOptionalGestures(){
  const area = testPair;
  let startX=0, startY=0, dx=0, dy=0, touching=false;
  const THRESH_X = 55, THRESH_Y = 80;
  function onStart(e){ const t=e.touches?e.touches[0]:e; startX=t.clientX; startY=t.clientY; dx=dy=0; touching=true; }
  function onMove(e){ if(!touching) return; const t=e.touches?e.touches[0]:e; dx=t.clientX-startX; dy=t.clientY-startY; }
  function onEnd(){
    if(!touching) return; touching=false;
    if(mode!=="pr√ºfen") return;
    if(testPhase==="prompt"){ revealAnswer(); return; }
    // in der Answer-Phase optional: Wischen rechts=‚úÖ, links=‚ùå
    if(Math.abs(dy) > THRESH_Y) return;
    if(dx > THRESH_X){ btnRight.click(); return; }
    if(dx < -THRESH_X){ btnWrong.click(); return; }
  }
  ["touchstart","mousedown"].forEach(ev=> area.addEventListener(ev, onStart, {passive:true}));
  ["touchmove","mousemove"].forEach(ev=> area.addEventListener(ev, onMove, {passive:true}));
  ["touchend","mouseup","mouseleave"].forEach(ev=> area.addEventListener(ev, onEnd));
})();

/* === Start === */
function initIDs(){ [activeCards,reserveCards,learnedCards].forEach(a=>a.forEach(c=>{ if(!c.id) c.id=cryptoRandom(); })); }
initIDs(); autoFillBox1(); rebuildLearnOrder(); render();

/* === PWA SW (falls vorhanden) === */
if('serviceWorker' in navigator){ addEventListener('load', ()=>navigator.serviceWorker.register('./service-worker.js').catch(console.error)); }
</script>
</body>
</html>
